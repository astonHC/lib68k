/* COPYRIHGT (C) HARRY CLARK 2024 */

/* MOTOROLA 68000 STANDALONE EMULATION LIBRARY */

/* THIS FILE ACTS AS AN EXPANSION OF THE PRE-REQUISTIES DEFINED IN THE MAIN CPU HEADER */
/* PROVIDING MOODULARISATION AND CROSS COMPILATION FOR OPCODE RELATED HANDLERS */

/* NESTED INCLUDES */

#include "68KOPCODE.h"

#ifdef BUILD_OP_TABLE

/* EXCEPTION HANDLER FOR A-LINE INSTRUCTION HANDLERS */
/* DISCERN THE CURRENT EXCEPTION BEING FED INTO PC AND APPEND THAT THROUGH A JMP */ 

void M68K_OP_1010(void)
{
    M68K_SET_FUNC_CALLBACK(M68K_REG_PC);
    M68K_JUMP_VECTOR(M68K_EXCEPTION_1010);

    /* USE THE INTEGREAL POINTER NOTATION TO ACCESS THE EXCEPTION FROM THE CURRENT A-LINE INSTRUCTION */
    /* PROVIDE ACCESS TO THE INDEX REGISTER */

    M68K_USE_CYCLES(M68K_CYC_EXCE[M68K_EXCEPTION_1010] - (M68K_CYC_EXCE[*M68K_REG_IR]));
}

/* SAME THING BUT FOR F-LINE INSTRUCTION HANDLERS */

void M68K_OP_1111(void)
{
    M68K_SET_FUNC_CALLBACK(M68K_REG_PC);
    M68K_JUMP_VECTOR(M68K_EXCEPTION_1111);

    M68K_USE_CYCLES(M68K_CYC_EXCE[M68K_EXCEPTION_1111] - (M68K_CYC_EXCE[*M68K_REG_IR]));

}

/* THE FOLLOWING WILL REFER TO THE BITWISE MEANS BY WHICH ALL OF THESE OPCODES OPERATE */
/* ALL OF THE SUBSEQUENT INFORMATION CAN BE SOURED FROM: https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf */

/* FORTUNTATELY, THERE IS A LOT OF INFORMATION PERTAINING TOWARDS HOW EVERYTHING WORKS IN THE DESC */
/* THERE IS A LOT OF NUANCE WITH THESE INSTRUCTIONS - SO THE ORDER OF OPERATIONS WILL VARY */

/* THE GENERAL JYST IS WORKING WITH POINTERS BETWEEN A SOURCE AND A DESTINATION */

/* SEE INTEGER INSTRUCTIONS: https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf#PAGE=105 */

void M68K_OP_ABCD_BYTE(void)
{
    int* DESTINATION = 0;
    int SRC = 0;


}   


#endif